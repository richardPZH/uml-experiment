/*
 * 2012/2/7 IMS@SCUT nemosail@gmail.com 739223715@qq.com
 * This is the main file of u_fs file system.
 * I think that if I follow the hello example pettern, I can finish the assignment.
 * u_fs.c
 *
 * fprintf(stderr,"*************Meaasge*********: %s , %d\n",__FILE__ , __LINE__);
*/

#define FUSE_USE_VERSION 26

//from hello.c application pettern
#include <fuse.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>

//suggested by document
#include "Global.h"
#include "Super_block.h"
#include "Directory.h"
#include "Files.h"

#include "Block_manpulate.h"
//#include "Block_manpulate.c" //when make file is engaged no longer useful

/*
 * u_fs_getattr
 * Description:
 * This function should look up the input path to
 * determine if it is a directory or a file. If it is a
 * directory, return the appropriate permissions. If it is
 * a file, return the appropriate permissions as well as
 * the actual size. This size must be accurate since it is
 * used to determine EOF and thus read may not be
 * called.
 *
 * UNIX
 * Equivalent:  man -s 2 stat
 *
 * Return values: 0 on success, with a correctly set structure
 * -ENOENT if the file is not found
 *
 * hint:
 * sscanf(path, "/%[^/]/%[^.].%s", directory, filename, extension);
 *
 * 
*/
static int u_fs_getattr ( const char *path , struct stat *stbuf)
{
    int res =0;

    fprintf(stderr,"Meaasge*******getattr:path=%s , %s , %d\n",path ,__FILE__ , __LINE__);
    memset( stbuf , 0 , sizeof( struct stat ));

    char drt[MAX_FILENAME + 2]; //this is a bad habit      /dir/fln.ext  
    char fln[MAX_FILENAME + MAX_EXTENSION + 2];
    char ext[MAX_EXTENSION + 2];

    struct u_fs_file_directory_entry entry;

    drt[0]='\0'; //zero initialize
    fln[0]='\0';
    ext[0]='\0';

    sscanf(path, "/%[^/]/%s", drt, fln );

    if( *drt == '\0' )       //file is "/" 
    {
        fprintf(stderr,"Meaasge*******getattr: file is /\n");
	stbuf->st_mode = S_IFDIR | 0777;
	stbuf->st_nlink = 2;             //don't know
    }
    else //file is in the root or the subroot
    {
	fprintf(stderr,"Message****getattr: file in the root or subroot\n" );

	if( u_fs_get_entry( path , &entry ) < 0 )
	    res = -ENOENT;
	else {

	if( entry.flag == iDIRECTORY )
	{
            //it is a directory
	    stbuf->st_mode = S_IFDIR | 0755;
	    stbuf->st_nlink = 1;
	    stbuf->st_size  = entry.fsize;
	    //directory have size too. but it indicate how many files
        }
       else if( entry.flag == iFILE )
       {
            //it is a file
	    stbuf->st_mode = S_IFREG | 0666;
	    stbuf->st_nlink = 1;
	    stbuf->st_size = entry.fsize; 
       }
    }}

	

    if( res < 0 )
	    fprintf(stderr,"Message******* find faild:%s\n", path );
    else
	    fprintf(stderr,"Message******* find success:%s\n", path );


    return res;
}



/*
 * Description: 
 * This function should look up the input path, ensuring
 * that it is a directory, and then list the contents.
 * To list the contents, you need to use the filler()
 * function. For example: filler(buf, ".", NULL, 0);
 * adds the current directory to the listing generated by
 * ls -a
 * In general, you will only need to change the second
 * parameter to be the name of the file or directory you
 * want to add to the listing.
 *
 * UNIX
 * Equivalent: man -s 2 readdir
 * However itâ€™s not exactly equivalent
 *
 * Return values: 0 on success
 * -ENOENT if the directory is not valid or found
 *
*/
static int u_fs_readdir( const char *path , void *buf , fuse_fill_dir_t filler, off_t offset , struct fuse_file_info *fi)
{
    (void) offset;
    (void) fi;

    fprintf(stderr,"*************Meaasge*********readdir path:%s: %s , %d , %s\n",path ,__FILE__ , __LINE__, __FUNCTION__ );
    filler( buf , "." , NULL , 0 );
    filler( buf , "..", NULL , 0 );

    char drt[10]; //this is a bad habit      /dir/fln.ext  
    char fln[10];
    char ext[10];

    struct u_fs_file_directory_entry entry;
    struct u_fs_file_directory_entry *p;
    struct u_fs_disk_block block;

    drt[0]='\0'; //zero initialize
    fln[0]='\0';
    ext[0]='\0';


    sscanf(path, "/%[^/]/%s", drt, fln );

    long dir_location;

    dir_location = ( SUPER_BLOCK_N + BITMAP_BLOCK_N ) * BLOCK_SIZE ;

    if( drt[0] != '\0' )
    {
	if( u_fs_find_entry( dir_location , drt , &entry ) < 0 )
	    return -ENOENT;
	if( entry.flag != iDIRECTORY )
	    return -ENOENT;

	dir_location = entry.nStartBlock;
    }

    size_t size;
    int i;

    fprintf(stderr,"*************Meaasge*********readdir: %s , %d\n",__FILE__ , __LINE__);

    while( dir_location !=0 )
    {
	if( u_fs_read_block( &block , dir_location ) < 0 )
        {
	    fprintf( stderr , "Error on reading block():%s" , strerror(errno));
	    return -ENOENT;
        }

	dir_location = block.nNextBlock;
	size = block.size;
	p = ( struct u_fs_file_directory_entry * ) block.data;
	
        fprintf(stderr,"*************Meaasge*********readdir: block.size : %d , block.nNextBlock : %ld\n",size,dir_location );

	for( i=0; i< (size / sizeof( struct u_fs_file_directory_entry )); i++ )
	{

            fprintf(stderr,"*************Meaasge*********readdir: p->fname : %s\n",p->fname );

	    if( p->fname[0] == '\0' )
	    {
		i--;
	    }
	    else
	    {
    		filler( buf , p->fname , NULL , 0 );
	    }
	    p++;
	}
    }


    fprintf(stderr,"*************Meaasge*********readdir end: %s , %d\n",__FILE__ , __LINE__);

    return 0;
}


/*
 * u_fs_read
 * Description: 
 * This function should read the data in the file denoted
 * by path into buf, starting at offset.
 *
 * UNIX
 * Equivalent:  man -s 2 read
 *
 * Return values: size read on success
 * -EISDIR if the path is a directory
 *
*/
static int u_fs_read( const char *path , char *buf , size_t size , off_t offset, struct fuse_file_info *fi)
{
    (void) fi;

    struct u_fs_file_directory_entry entry;

    if( strcmp( path , "/" ) == 0 )
	return -EISDIR;                        //can't read "/"

    if( u_fs_get_entry( path , &entry ) < 0 )  //can't find entry
	return -ENOENT;

    if( entry.flag == iDIRECTORY )             //path is directory
	return -EISDIR;

    long nStartBlock = entry.nStartBlock;
    struct u_fs_disk_block ablock;

    if( u_fs_read_block( &ablock , nStartBlock ) < 0 )
	return -ENOENT;

    while( offset >= ablock.size )  //go to the offset
    {
	offset-= ablock.size;
        if( u_fs_read_block( &ablock , ablock.nNextBlock) < 0 )
            return -ENOENT;
    }

    //start reading
    size_t count=0;
    int icount;
    int tcount;
    while( size > 0 )
    {
	tcount = ablock.size - offset;
	if( size < tcount )
	{
	    tcount = size ;
	    size = 0;
	}
	else
	{
	    size -= tcount;
	}

	for( icount=0; icount < tcount ; icount++ )
	{
	    buf[count] = ablock.data[offset+icount];
	    count++;
	}

	offset=0;    //no more offset

	if( size > 0 )
	{
	    if( u_fs_read_block( &ablock , ablock.nNextBlock) < 0 )   //if ablock.nNextBlock ==0 it will return < 0
                return count;
	}
    }

    return count;
}

//u_fs_write
//Description: This function should write the data in buf into the file
//denoted by path, starting at offset.
//
//UNIX
//Equivalent: man -s 2 write
//
//Return values: size on success
//-EFBIG if the offset is beyond the file size (but handle //appends)
//
static int u_fs_write( const char *path , const char *buf , size_t size , off_t offset , struct fuse_file_info *fi )
{
    fprintf( stderr , "Message****** u_fs_write : %s , %d\n" , __FILE__ , __LINE__ );
    fprintf( stderr , "Message****** u_fs_write : path=%s , size to write=%d , offset=%d\n" , path ,(int) size ,(int) offset );

    if( size <= 0 )    //simply return the error size
	return size;

    int new_offset;

    int size_remain;
    int size_written;

    long blk_location;

    struct u_fs_file_directory_entry entry;
    struct u_fs_disk_block block;

    if( u_fs_get_entry( path , &entry ) < 0 )  //the file in the path do not exist
    {
    	fprintf( stderr , "Message****** u_fs_write : path=%s not found\n" , path );
	return -ENOENT;
    }

    //file exist
    if( entry.flag != iFILE )                  //it is a dir do not write
    {
    	fprintf( stderr , "Message****** u_fs_write : path=%s is not a regular file\n" , path );
	return -EISDIR;
    }

    if( offset > entry.fsize )                 //offset beyond the file size
    {
    	fprintf( stderr , "Message****** u_fs_write : offset=%ld is too big\n" , (long)offset );
	return -EFBIG;
    }

    fprintf( stderr , "Message**** write :entry.fname=%s,entry.fsize = %d; entry.nStartBlock=%ld\n" , entry.fname , entry.fsize , entry.nStartBlock );

    //the size of the file may be change due to the write and offset need to update the entry
    //is the size of the file changed?
    if( size > ( entry.fsize - offset ) )
	entry.fsize = size + offset ;         //this entry shall be updated

    if( entry.nStartBlock == 0 )              //if the file is enpty at first new a clean block to him
    {
	entry.nStartBlock = u_fs_find_next_avaiable_block();
	
	u_fs_read_block( &block , entry.nStartBlock );

	fprintf( stderr , "Message**** write : new a block , block.size=%d; block.nNextBlock=%ld;\n" , block.size , block.nNextBlock );
    }

    if( entry.nStartBlock <= 0 )
    {
	//error no space
	fprintf( stderr , "Message***** u_fs_write : no space avaiable!\n");
	return 0;
    }

    u_fs_update_entry( path , &entry );      //this is viatl
    fprintf( stderr , "Message***** u_fs_write : updated file=%s size=%d\n" , path , (int) entry.fsize);
    //update the entry finish

    //go the the correct offset
    blk_location = entry.nStartBlock;

    u_fs_read_block( &block , blk_location );
    
    new_offset = 0 ;

    while( offset != 0 )
    {
        u_fs_read_block( &block , blk_location );
	
	if( offset >= MAX_DATA_IN_BLOCK ) //offset is in the next block	    
	{
	    offset -= block.size;
	    new_offset = offset;
         
	    if( block.nNextBlock == 0 )              //if the file is enpty at first new a clean block to him
	    {
		block.nNextBlock = u_fs_find_next_avaiable_block();
	        

                if( block.nNextBlock <= 0 )
                {
	            //error no space
	            fprintf( stderr , "Message***** u_fs_write : no space avaiable!\n");
         	    return 0;
	        }

	        u_fs_write_block( &block , blk_location );

		fprintf( stderr , "Message**** write : new a block , block.size=%d; block.nNextBlock=%ld;\n" , block.size , block.nNextBlock );
	    }

	    blk_location = block.nNextBlock;  
        }
    	else
	{
    	    new_offset = offset;
	    offset = 0;
	}
    }


    fprintf( stderr , "Message***** u_fs_write : go to offset...ok! new_offset is %d\n" ,(int) new_offset );

    //from now on new_offset is in use

    //now the block is to be written and write back to disk
    //start writing
    size_remain = size;     //start we have size of byte to write
    size_written = 0;       //we havn't write anything

    while( size_remain > 0 )
    {
	if( MAX_DATA_IN_BLOCK - new_offset >= size_remain )  //this block can hold all the data
	{
	    if( ( new_offset + size_remain ) > block.size )  //is becamming bigger? 
		block.size = new_offset + size_remain;

	    memcpy( block.data + new_offset , buf + size_written , size_remain );

	    u_fs_write_block( &block , blk_location );

	    size_written += size_remain;
	    size_remain = 0;
	}
	else                                      //this block is not big enough
	{
	    memcpy( block.data + new_offset , buf + size_written , MAX_DATA_IN_BLOCK - new_offset );

	    block.size = MAX_DATA_IN_BLOCK;
	    
            if( block.nNextBlock == 0 )              //if the file is enpty at first new a clean block to him
		block.nNextBlock = u_fs_find_next_avaiable_block();

            if( block.nNextBlock <= 0 )
	    {
		//error no space
		fprintf( stderr , "Message***** u_fs_write : no space avaiable!\n");
		return size_written;
	    }	

	    u_fs_write_block( &block , blk_location );  //block can be write back now

	    blk_location = block.nNextBlock;

	    u_fs_read_block( &block ,blk_location );

	    size_written += MAX_DATA_IN_BLOCK - new_offset;
	    size_remain -= MAX_DATA_IN_BLOCK - new_offset;

	    new_offset = 0;
	}


    }

    fprintf( stderr , "Message***** write final block's next block is %ld\n" , block.nNextBlock );
    fprintf( stderr , "Message***** write finishe , byte written=%d ", (size_written ));

    return size_written;
}


//u_fs_mkdir
//Description: This function should add the new directory to the root
//level, and should update the .directories file
//appropriately.
//
//UNIX
//Equivalent: man -s 2 mkdir
//
//Return values: 0 on success
//-ENAMETOOLONG if the name is beyond 8 chars
//-EPERM if the directory is not under the root dir only
//-EEXIST if the directory already exists
//
static int u_fs_mkdir ( const char * path , mode_t mode )
{
    char drt[ MAX_FILENAME + 2];
    char fln[ MAX_FILENAME + MAX_EXTENSION + 2];
    char ext[ MAX_EXTENSION + 2];

    drt[0]='\0';
    fln[0]='\0';
    ext[0]='\0';

    if( strlen( path ) > 8 + 2 ) //directory name too long
	return -ENAMETOOLONG;  

    sscanf(path, "/%[^/]/%s", drt, fln);

    struct u_fs_file_directory_entry entry;

    if( u_fs_get_entry( path , &entry ) >= 0 )  //dir or file already exist
	return -EEXIST;
    
    fprintf(stderr,"*************Meaasge*********file not exist: %s , %d\n",__FILE__ , __LINE__);

    if( drt[0] == '\0' )  //new '/' ?
	return -EPERM;
    fprintf(stderr,"*************Meaasge*********not /: %s , %d\n",__FILE__ , __LINE__);

    if( fln[0] != '\0' )  //subdirectory shall not new directory
	return -EPERM;

    fprintf(stderr,"*************Meaasge*********not subroot: %s , %d\n",__FILE__ , __LINE__);

    if( strlen( drt ) > MAX_FILENAME + 2 ) //directory name too long
	return -ENAMETOOLONG;  

    fprintf(stderr,"*************Meaasge*********name ok: %s , %d\n",__FILE__ , __LINE__);

    //insert entry to root directory
    strcpy( entry.fname , drt );
    entry.fext[0]='\0';
    entry.fsize = 0;
    entry.nStartBlock = u_fs_find_next_avaiable_block();
    entry.flag=iDIRECTORY;

    struct sb sb_info;
    u_fs_read_superblock( &sb_info );
    fprintf( stderr, "\nMessage mkdir :\n");
    fprintf( stderr, "fs_size : %ld\n" , sb_info.fs_size);
    fprintf( stderr, "us_size : %ld\n" , sb_info.us_size);
    fprintf( stderr, "bk_size : %ld\n" , sb_info.bk_size);

    if( entry.nStartBlock < 0 )  //no more space in disk
    {
	fprintf(stderr,"Meaasge*********mkdir:error on find block. disk full. %s , %d\n",__FILE__ , __LINE__);
	return -ENAVAIL;
    }

    //write an empty block
    struct u_fs_disk_block block;
    memset( &block , 0 , sizeof( struct u_fs_disk_block ));
    block.size = 0;
    block.nNextBlock =0;

    u_fs_write_block( &block , entry.nStartBlock );

    //insert entry
    u_fs_insert_entry( "/" , &entry );

    fprintf(stderr,"*************Meaasge*********insert subdir to /: %s , %d\n",__FILE__ , __LINE__);
    return 0;
}

//u_fs_rmdir
//Description: Deletes an empty directory
//
//UNIX
//Equivalent:  man -s 2 rmdir
//
//Return values: 0 read on success
//-ENOTEMPTY if the directory is not empty
//-ENOENT if the directory is not found
//-ENOTDIR if the path is not a directory
static int u_fs_rmdir( const char *path )
{
    fprintf(stderr,"Meaasge*********rmdir:path=%s , %s , %d\n",path, __FILE__ , __LINE__);

    struct u_fs_file_directory_entry entry;

    if( u_fs_get_entry( path , &entry) < 0 )  //entry not found
    {
        fprintf(stderr,"Meaasge*********rmdir: path=%s not found\n", path );
	return -ENOENT;
    }

    //entry found
    if( entry.flag != iDIRECTORY )           //file is not a directory
    {
        fprintf(stderr,"Meaasge*********rmdir: path=%s is not a directory\n", path );
	return -ENOTDIR;
    }

    if( entry.fsize != 0 )                   //directory not empty
    {
        fprintf(stderr,"Meaasge*********rmdir: path=%s is not empty\n", path);
	return -ENOTEMPTY;
    }

    fprintf(stderr,"Meaasge*********rmdir:path=%s is an empty directory can be deleted\n",path );

    //now the directory is empty. delete it, update the root and bitmap empty dir only has one block
    u_fs_free_block( entry.nStartBlock );

    //directory is inside the root only
    return u_fs_remove_entry( "/" , &entry);
   
}


//u_fs_ulink
//Description: Delete a file
//
//UNIX
//Equivalent:  man -s 2 unlink
//
//Return values: 0 read on success
//-EISDIR if the path is a directory
//-ENOENT if the file is not found
static int u_fs_unlink( const char *path )
{

    fprintf(stderr,"Meaasge*********unlink : %s , %d\n",__FILE__ , __LINE__);

    struct u_fs_file_directory_entry entry;

    if( strlen( path ) > (MAX_FILENAME * 2 +2) ) //directory name too long
	return -ENAMETOOLONG;  

    if( strcmp( path , "/" ) == 0 )
	return -EISDIR;

    if( u_fs_get_entry( path , &entry ) < 0 ) //entry not found
	return -ENOENT;
    
    if( entry.flag == iDIRECTORY )            //entry is a directory
	return -EISDIR;

    //delete unused block and update the bitmap
    long block_location;
    struct u_fs_disk_block block;
    
    block_location = entry.nStartBlock;

    fprintf(stderr,"Meaasge*********unlink : start to free block. block location is :%ld\n" , block_location );

    while( block_location > (long )0 )
    {
	u_fs_read_block( &block , block_location );

        fprintf(stderr,"Meaasge*********unlink : free one block , next block to free :%ld\n" , block.nNextBlock );

	u_fs_free_block( block_location );

	block_location = block.nNextBlock;
    }

#if 0
    //update the directory 
    char drt[ MAX_FILENAME + 2];
    char fln[ MAX_FILENAME + MAX_EXTENSION + 2];
    char ext[ MAX_EXTENSION + 2];
    char npath[ MAX_FILENAME * 4];

    drt[0]='\0';
    fln[0]='\0';
    ext[0]='\0';
    npath[0]='/';
    npath[1]='\0';

    sscanf(path, "/%[^/]/%s", drt, fln);

    if( fln[0] != '\0' )
    {
	//file is in the subroot
	strcpy( npath+1 , drt );
    }
#endif

    fprintf(stderr,"Meaasge*********unlink : file block free finish. starting to remove entry.\n");

    return u_fs_remove_entry( path , &entry );
}


//u_fs_mknod
//Description: This function should add a new file to a subdirectory,
//and should update the .directories file
//appropriately with the modified directory entry
//structure.
//
//UNIX
//Equivalent: man -s 2 mknod
//
//Return values: 0 on success
//-ENAMETOOLONG if the name is beyond 8.3 chars
//-EPERM if the file is trying to be created in the root dir //not implement
//-EEXIST if the file already exists
static int u_fs_mknod( const char * path , mode_t mode , dev_t rdev )
{
    fprintf(stderr,"Meaasge*********mknod:path is %s , %s , %d , %s\n", path , __FILE__ , __LINE__, __FUNCTION__ );

    if( strlen( path ) > ( MAX_FILENAME * 2 + MAX_EXTENSION * 2 + 2 ))
       return -ENAMETOOLONG;	

    struct u_fs_file_directory_entry entry;

    if( u_fs_get_entry( path , &entry ) >= 0 )   //this file already exists
	return -EEXIST;

    fprintf(stderr,"Meaasge*********file can be create %s , %d , %s\n",__FILE__ , __LINE__, __FUNCTION__ );

    entry.fsize = 0;
    entry.nStartBlock = 0;
    entry.flag = iFILE;

    char drt[22];
    char fln[22];
    char ext[22];
    char npath[22];

    drt[0]='\0';
    fln[0]='\0';
    ext[0]='\0';
    npath[0]='/';
    npath[1]='\0';

    sscanf(path,"/%[^/]/%[^.].%s", drt , fln ,ext ); 
    if( strlen( ext ) > MAX_EXTENSION )
	return -ENAMETOOLONG;

    sscanf(path, "/%[^/]/%s", drt, fln);

    strcpy( npath+1 , drt );

    if( fln[0] == '\0' )
    {
	strcpy( npath , "/" );
	sscanf( path , "/%[^/]", fln );
    }


    //file is created on subdirectory
    if( strlen( fln ) > 8 + 3 + 1 )
	return -ENAMETOOLONG;

    strcpy( entry.fname , fln );

    strcpy( entry.fext  , ext );


    fprintf(stderr,"Meaasge*******mknod path:%s, entry fname:%s fext:%s , %s , %d , %s\n", path , entry.fname , entry.fext ,__FILE__ , __LINE__, __FUNCTION__ );
    return u_fs_insert_entry( path , &entry );

}

//u_fs_open
//This function should not be modified, as you get the full path every time
//any of the other functions are called.
static int u_fs_open(const char *path, struct fuse_file_info *fi)
{
    //just return 0 ?
    return 0;
}


//u_fs_flush
//This function should not be modified.
//
static int u_fs_flush( const char * path , struct fuse_file_info *fi)
{
    //just return 0 ?
    return 0;
}

//u_fs_truncate
//This function should not be modified.
int u_fs_truncate(const char *path , off_t offset )
{
    //just return 0?
    return 0;
}

static struct fuse_operations u_fs_oper = {
    .getattr  = u_fs_getattr,
    .readdir  = u_fs_readdir,
    .read     = u_fs_read,
    .mkdir    = u_fs_mkdir,
    .rmdir    = u_fs_rmdir,
    .open     = u_fs_open,
    .flush    = u_fs_flush,
    .truncate = u_fs_truncate,
    .unlink   = u_fs_unlink,
    .mknod    = u_fs_mknod,
    .write    = u_fs_write,
};


int main( int argc , char ** argv )
{
    return fuse_main(argc, argv, &u_fs_oper, NULL);
}


//no longer use code below

#if 0
	//a bad version of getattr!!
	fprintf(stderr,"Message****getattr: file in the root\n" );

	if( u_fs_find_entry( (SUPER_BLOCK_N + BITMAP_BLOCK_N )*BLOCK_SIZE, drt , &entry ) < 0 ) //file not found
	{
	    res = -ENOENT;
	}
	else                                                                                    //file found
	{
	    if( entry.flag == iDIRECTORY )
	    {
		//it is a directory
		stbuf->st_mode = S_IFDIR | 0755;
		stbuf->st_nlink = 1;
	    }
	    else if( entry.flag == iFILE )
	    {
		//it is a file
		stbuf->st_mode = S_IFREG | 0666;
		stbuf->st_nlink = 1;
		stbuf->st_size = entry.fsize; 
	    }
	}
    }
    else                //file is in the subdirectory
    {
	fprintf(stderr,"Message****getattr: file in the subdirectory\n" );

	if( u_fs_find_entry( (SUPER_BLOCK_N + BITMAP_BLOCK_N )*BLOCK_SIZE, drt , &entry ) < 0 ) //file not found
	{
	    fprintf(stderr,"*******Message******* find faild:%s %s  %s , %d\n", path , drt , __FILE__ , __LINE__ );
	    res = -ENOENT;
	}
	else  //file found
	{
	    if( entry.flag == iDIRECTORY )
	    {
		//continue to search
		if( u_fs_find_entry( entry.nStartBlock , fln , &entry ) < 0 )
		    res = -ENOENT;
		else
		{
           	    if( entry.flag == iDIRECTORY )
	            {
		   	//it is a directory
			stbuf->st_mode = S_IFDIR | 0755;
			stbuf->st_nlink = 1;
		    }
		    else if( entry.flag == iFILE )
		    {
			//it is a file
			stbuf->st_mode = S_IFREG | 0666;
			stbuf->st_nlink = 1;
			stbuf->st_size = entry.fsize; 
		    }

		}
	    }
	    else //error path
		res= -ENOENT;
	}
#endif
