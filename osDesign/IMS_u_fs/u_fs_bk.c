/*
 * 2012/2/7 IMS@SCUT nemosail@gmail.com 739223715@qq.com
 * This is the main file of u_fs file system.
 * I think that if I follow the hello example pettern, I can finish the assignment.
 * u_fs.c
 *
 * fprintf(stderrr,"*************Meaasge*********: %s , %d\n",__FILE__ , __LINE__);
*/

#define FUSE_USE_VERSION 26

//from hello.c application pettern
#include <fuse.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>

//suggested by document
#include "Global.h"
#include "Super_block.h"
#include "Directory.h"
#include "Files.h"

#include "Block_manpulate.c"

/*
 * u_fs_getattr
 * Description:
 * This function should look up the input path to
 * determine if it is a directory or a file. If it is a
 * directory, return the appropriate permissions. If it is
 * a file, return the appropriate permissions as well as
 * the actual size. This size must be accurate since it is
 * used to determine EOF and thus read may not be
 * called.
 *
 * UNIX
 * Equivalent:  man -s 2 stat
 *
 * Return values: 0 on success, with a correctly set structure
 * -ENOENT if the file is not found
 *
 * hint:
 * sscanf(path, "/%[^/]/%[^.].%s", directory, filename, extension);
 *
 * 
*/
static int u_fs_getattr ( const char *path , struct stat *stbuf)
{
    int res =0;

    memset( stbuf , 0 , sizeof( struct stat ));

    char drt[10]; //this is a bad habit      /dir/fln.ext  
    char fln[10];
    char ext[10];

    struct u_fs_file_directory_entry entry;

    drt[0]='\0'; //zero initialize
    fln[0]='\0';
    ext[0]='\0';

    sscanf(path, "/%[^/]/%[^.].%s", drt, fln, ext);

    if( *drt == '\0' )       //file is "/" 
    {
	stbuf->st_mode = S_IFDIR | 0777;
	stbuf->st_nlink = 2;             //don't know
    }
    else if( *fln == '\0' )  //file is in the root 
    {
	if( u_fs_find_entry( (SUPER_BLOCK_N + BITMAP_BLOCK_N )*BLOCK_SIZE, drt , &entry ) < 0 ) //file not found
	{
	    fprintf(stderr,"*******Message******* find faild:%s %s  %s , %d", path , drt , __FILE__ , __LINE__ );
	    res = -ENOENT;
	}
	else                                                                                    //file found
	{
	    if( entry.flag == iDIRECTORY )
	    {
		//it is a directory
		stbuf->st_mode = S_IFDIR | 0755;
		stbuf->st_nlink = 1;
	    }
	    else if( entry.flag == iFILE )
	    {
		//it is a file
		stbuf->st_mode = S_IFREG | 0666;
		stbuf->st_nlink = 1;
		stbuf->st_size = entry.fsize; 
	    }
	}
    }
    else                //file is in the subdirectory
    {
	if( u_fs_find_entry( (SUPER_BLOCK_N + BITMAP_BLOCK_N )*BLOCK_SIZE, drt , &entry ) < 0 ) //file not found
	{
	    res = -ENOENT;
	}
	else  //file found
	{
	    if( entry.flag == iDIRECTORY )
	    {
		//continue to search
		if( u_fs_find_entry( entry.nStartBlock , fln , &entry ) < 0 )
		    res = -ENOENT;
		else
		{
           	    if( entry.flag == iDIRECTORY )
	            {
		   	//it is a directory
			stbuf->st_mode = S_IFDIR | 0755;
			stbuf->st_nlink = 1;
		    }
		    else if( entry.flag == iFILE )
		    {
			//it is a file
			stbuf->st_mode = S_IFREG | 0666;
			stbuf->st_nlink = 1;
			stbuf->st_size = entry.fsize; 
		    }

		}
	    }
	    else //error path
		res= -ENOENT;
	}
    }

    return res;
}



/*
 * Description: 
 * This function should look up the input path, ensuring
 * that it is a directory, and then list the contents.
 * To list the contents, you need to use the filler()
 * function. For example: filler(buf, ".", NULL, 0);
 * adds the current directory to the listing generated by
 * ls -a
 * In general, you will only need to change the second
 * parameter to be the name of the file or directory you
 * want to add to the listing.
 *
 * UNIX
 * Equivalent: man -s 2 readdir
 * However itâ€™s not exactly equivalent
 *
 * Return values: 0 on success
 * -ENOENT if the directory is not valid or found
 *
*/
static int u_fs_readdir( const char *path , void *buf , fuse_fill_dir_t filler, off_t offset , struct fuse_file_info *fi)
{
    (void) offset;
    (void) fi;

    fprintf(stderr,"*************Meaasge*********readdir path:%s: %s , %d , %s\n",path ,__FILE__ , __LINE__, __FUNCTION__ );
    filler( buf , "." , NULL , 0 );
    filler( buf , "..", NULL , 0 );

    char drt[10]; //this is a bad habit      /dir/fln.ext  
    char fln[10];
    char ext[10];

    struct u_fs_file_directory_entry entry;
    struct u_fs_file_directory_entry *p;
    struct u_fs_disk_block block;

    drt[0]='\0'; //zero initialize
    fln[0]='\0';
    ext[0]='\0';


    sscanf(path, "/%[^/]/%[^.].%s", drt, fln, ext);

    long dir_location;

    dir_location = ( SUPER_BLOCK_N + BITMAP_BLOCK_N ) * BLOCK_SIZE ;

    if( drt[0] != '\0' )
    {
	if( u_fs_find_entry( dir_location , drt , &entry ) < 0 )
	    return -ENOENT;
	if( entry.flag != iDIRECTORY )
	    return -ENOENT;

	dir_location = entry.nStartBlock;
    }

    size_t size;
    int i;

    fprintf(stderr,"*************Meaasge*********readdir: %s , %d\n",__FILE__ , __LINE__);

    while( dir_location !=0 )
    {
	if( u_fs_read_block( &block , dir_location ) < 0 )
        {
	    fprintf( stderr , "Error on reading block():%s" , strerror(errno));
	    return -ENOENT;
        }

	dir_location = block.nNextBlock;
	size = block.size;
	p = ( struct u_fs_file_directory_entry * ) block.data;
	
        fprintf(stderr,"*************Meaasge*********readdir: block.size : %d , block.nNextBlock : %ld\n",size,dir_location );

	for( i=0; i< (size / sizeof( struct u_fs_file_directory_entry )); i++ )
	{

            fprintf(stderr,"*************Meaasge*********readdir: p->fname : %s\n",p->fname );

	    if( p->fname[0] == '\0' )
	    {
		i--;
	    }
	    else
	    {
		filler( buf , p->fname , NULL , 0 );
	    }
	    p++;
	}
    }


    fprintf(stderr,"*************Meaasge*********readdir end: %s , %d\n",__FILE__ , __LINE__);

    return 0;
}


/*
 * u_fs_read
 * Description: 
 * This function should read the data in the file denoted
 * by path into buf, starting at offset.
 *
 * UNIX
 * Equivalent:  man -s 2 read
 *
 * Return values: size read on success
 * -EISDIR if the path is a directory
 *
*/
static int u_fs_read( const char *path , char *buf , size_t size , off_t offset, struct fuse_file_info *fi)
{
    size_t len;
    (void) fi;

    struct u_fs_file_directory_entry entry;

    if( strcmp( path , "/" ) == 0 )
	return -EISDIR;                        //can't read "/"

    if( u_fs_get_entry( path , &entry ) < 0 )  //can't find entry
	return -ENOENT;

    if( entry.flag == iDIRECTORY )             //path is directory
	return -EISDIR;

    long nStartBlock = entry.nStartBlock;
    struct u_fs_disk_block ablock;

    if( u_fs_read_block( &ablock , nStartBlock ) < 0 )
	return -ENOENT;

    while( offset >= ablock.size )  //go to the offset
    {
	offset-= ablock.size;
        if( u_fs_read_block( &ablock , ablock.nNextBlock) < 0 )
            return -ENOENT;
    }

    //start reading
    size_t count=0;
    int icount;
    int tcount;
    while( size > 0 )
    {
	tcount = ablock.size - offset;
	if( size < tcount )
	{
	    tcount = size ;
	    size = 0;
	}
	else
	{
	    size -= tcount;
	}

	for( icount=0; icount < tcount ; icount++ )
	{
	    buf[count] = ablock.data[offset+icount];
	    count++;
	}

	offset=0;    //no more offset

	if( size > 0 )
	{
	    if( u_fs_read_block( &ablock , ablock.nNextBlock) < 0 )   //if ablock.nNextBlock ==0 it will return < 0
                return count;
	}
    }

    return count;
}


//u_fs_mkdir
//Description: This function should add the new directory to the root
//level, and should update the .directories file
//appropriately.
//
//UNIX
//Equivalent: man -s 2 mkdir
//
//Return values: 0 on success
//-ENAMETOOLONG if the name is beyond 8 chars
//-EPERM if the directory is not under the root dir only
//-EEXIST if the directory already exists
//
static int u_fs_mkdir ( const char * path , mode_t mode )
{
    char drt[10];
    char fln[10];
    char ext[10];

    drt[0]='\0';
    fln[0]='\0';
    ext[0]='\0';

    if( strlen( path ) > 10 ) //directory name too long
	return -ENAMETOOLONG;  

    sscanf(path, "/%[^/]/%[^.].%s", drt, fln, ext);

    struct u_fs_file_directory_entry entry;

    if( u_fs_get_entry( path , &entry ) >= 0 )  //dir or file already exist
	return -EEXIST;
    
    fprintf(stderr,"*************Meaasge*********file not exist: %s , %d\n",__FILE__ , __LINE__);

    if( drt[0] == '\0' )  //new '/' ?
	return -EPERM;
    fprintf(stderr,"*************Meaasge*********not /: %s , %d\n",__FILE__ , __LINE__);

    if( fln[0] != '\0' )  //subdirectory shall not new directory
	return -EPERM;

    fprintf(stderr,"*************Meaasge*********not subroot: %s , %d\n",__FILE__ , __LINE__);

    if( strlen( drt ) > 8 ) //directory name too long
	return -ENAMETOOLONG;  

    fprintf(stderr,"*************Meaasge*********name ok: %s , %d\n",__FILE__ , __LINE__);

    //insert entry to root directory
    strcpy( entry.fname , drt );
    entry.fext[0]='\0';
    entry.fsize = 0;
    entry.nStartBlock = u_fs_find_next_avaiable_block();
    entry.flag=iDIRECTORY;

    //write an empty block
    struct u_fs_disk_block block;
    memset( &block , 0 , sizeof( struct u_fs_disk_block ));
    block.size = 0;
    block.nNextBlock =0;

    u_fs_write_block( &block , entry.nStartBlock );

    //insert entry
    u_fs_insert_entry( "/" , &entry );

    fprintf(stderr,"*************Meaasge*********insert subdir to /: %s , %d\n",__FILE__ , __LINE__);
    return 0;
}

//u_fs_rmdir
//Description: Deletes an empty directory
//
//UNIX
//Equivalent:  man -s 2 rmdir
//
//Return values: 0 read on success
//-ENOTEMPTY if the directory is not empty
//-ENOENT if the directory is not found
//-ENOTDIR if the path is not a directory
static int u_fs_rmdir( const char *path )
{
    fprintf(stderr,"*************Meaasge*********rmdir: %s , %d\n",__FILE__ , __LINE__);

    struct u_fs_file_directory_entry entry;

    if( u_fs_get_entry( path , &entry) < 0 )  //entry not found
	return -ENOENT;

    //entry found
    if( entry.flag != iDIRECTORY )           //file is not a directory
	return -ENOTDIR;

    if( entry.fsize != 0 )                   //directory not empty
	return -ENOTEMPTY;

    //now the directory is empty. delete it, update the root and bitmap empty dir only has one block
    u_fs_free_block( entry.nStartBlock );

    //directory is inside the root only
    return u_fs_remove_entry( "/" , &entry);
   
#if 0
    struct u_fs_disk_block block;
    struct u_fs_file_directory_entry *p;

    long dir_location;
    long old_location;

    dir_location = ( SUPER_BLOCK_N + BITMAP_BLOCK_N ) * BLOCK_SIZE ;

    size_t size;
    int i;

    fprintf(stderr,"*************Meaasge*********rmdir: %s , %d\n",__FILE__ , __LINE__);

    while( dir_location !=0 )
    {
	if( u_fs_read_block( &block , dir_location ) < 0 )
        {
	    fprintf( stderr , "Error on reading block():%s" , strerror(errno));
	    return -ENOENT;
        }

	old_location = dir_location;
	dir_location = block.nNextBlock;
	size = block.size;
	p = ( struct u_fs_file_directory_entry * ) block.data;
	
        fprintf(stderr,"*************Meaasge*********readdir: block.size : %d , block.nNextBlock : %ld\n",size,dir_location );

	for( i=0; i< (size / sizeof( struct u_fs_file_directory_entry )); i++ )
	{

            fprintf(stderr,"*************Meaasge*********readdir: p->fname : %s\n",p->fname );

	    if( p->fname[0] == '\0' )
	    {
		i--;    
	    }
	    else if( strcmp( p->fname , entry.fname ) == 0 )  //find it
	    {
		memset( p , 0 , sizeof( struct u_fs_file_directory_entry ));
		block.size -= sizeof( struct u_fs_file_directory_entry );    

		u_fs_write_block( &block , old_location ); 
		dir_location=0;
		break;
	    }
	    p++;
	}
    }

    return 0;
#endif
}


//u_fs_ulink
//Description: Delete a file
//
//UNIX
//Equivalent:  man -s 2 unlink
//
//Return values: 0 read on success
//-EISDIR if the path is a directory
//-ENOENT if the file is not found
static int u_fs_unlink( const char *path )
{

    struct u_fs_file_directory_entry entry;

    if( strlen( path ) > 20 ) //directory name too long
	return -ENAMETOOLONG;  

    if( u_fs_get_entry( path , &entry ) < 0 ) //entry not found
	return -ENOENT;
    
    if( entry.flag == iDIRECTORY )            //entry is a directory
	return -EISDIR;

    //delete unused block and update the bitmap
    long block_location;
    struct u_fs_disk_block block;
    
    block_location = entry.nStartBlock;

    while( block_location != 0 )
    {
	u_fs_read_block( &block , block_location );

	u_fs_free_block( block_location );

	block_location = block.nNextBlock;
    }

    //update the directory 
    char drt[10];
    char fln[10];
    char ext[10];
    char npath[11];

    drt[0]='\0';
    fln[0]='\0';
    ext[0]='\0';
    npath[0]='/';
    npath[1]='\0';

    sscanf(path, "/%[^/]/%[^.].%s", drt, fln, ext);

    if( fln[0] != '\0' )
    {
	//file is in the subroot
	strcpy( npath+1 , drt );
    }

    return u_fs_remove_entry( npath , &entry );
}

//u_fs_open
//This function should not be modified, as you get the full path every time
//any of the other functions are called.
static int u_fs_open(const char *path, struct fuse_file_info *fi)
{
    //just return 0 ?
    return 0;
}


//u_fs_flush
//This function should not be modified.
//
static int u_fs_flush( const char * path , struct fuse_file_info *fi)
{
    //just return 0 ?
    return 0;
}

//u_fs_truncate
//This function should not be modified.
int u_fs_truncate(const char *path , off_t offset )
{
    //just return 0?
    return 0;
}

static struct fuse_operations u_fs_oper = {
    .getattr  = u_fs_getattr,
    .readdir  = u_fs_readdir,
    .read     = u_fs_read,
    .mkdir    = u_fs_mkdir,
    .rmdir    = u_fs_rmdir,
    .open     = u_fs_open,
    .flush    = u_fs_flush,
    .truncate = u_fs_truncate,
    .unlink   = u_fs_unlink,
};


int main( int argc , char ** argv )
{
    return fuse_main(argc, argv, &u_fs_oper, NULL);
}
